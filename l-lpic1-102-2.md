# Learn linux, 101, 安装引导管理器

标签（空格分隔）： lpi-pre-exam 翻译
---

## 概览
在本教程中，学习如何为Linux系统选择，安装和配置启动管理器。 学会：
- 提供备用引导位置和备份引导选项
- 安装并配置引导加载程序，例如GRUB Legacy
- 执行GRUB 2的基本配置更改
- 与引导加载程序互交

## 引导管理器
引导管理器或引导加载程序是代码的中间代码，可帮助系统的硬件和固件为您加载操作系统。 本教程讨论了PC引导过程以及Linux中使用的三个主要引导加载程序：GRUB，GRUB 2和带有MBR格式磁盘的LILO。 最初的GRUB，现在称为GRUB-Legacy，不再处于活跃开发阶段，并且已经在很大程度上被新的GRUB 2取代。即使是商业发行版，如Red Hat Enterprise Linux和SUSE Linux Enterprise Server，也在2014年转向了Grub 2。 Lilo计划于2015年底停止。
本教程可帮助您为Linux Server Professional（LPIC-1）考试101的主题102中的目标102.2做准备。目标的权重为2. LPIC-1不再需要LILO。 它包含在这里，以便您了解它。

本教程重点介绍如何使用传统BIOS和使用主引导记录（MBR）格式化的磁盘进行引导。 它还介绍了可扩展统一固件接口（UEFI）及其相关GUID分区表（GPT）的一些基本信息以及您可能会发现的引导问题，特别是如果您需要在单个系统上同时启动Windows®8和Linux。

### 前置条件
要从本系列教程中获得最大收益，您应该具备Linux的基本知识和可以在其上练习所涵盖命令的Linux系统。 您还应该熟悉硬盘驱动器布局，如教学“学习Linux 101：硬盘布局”中所述。 有时程序的不同版本会以不同的方式格式化输出，因此您的结果可能并不总是与此处显示的列表和数字完全相同。

注意：本教程中的图像是从引导过程早期获取的屏幕截图。 如果您正在使用屏幕阅读器阅读本教程，您可能会发现使相应的配置文件可供参考是有利的; 从本教程后面的下载部分下载它们。

## 启动流程概览
在进入特定的启动加载器之前，让我们回顾一下传统PC的启动或启动方式。称为BIOS（用于基本输入输出服务）的代码存储在非易失性存储器中，例如ROM，EEPROM或闪存。打开或重新启动PC时，将执行此代码。通常它会执行开机自检（POST）来检查机器。最后，它从引导驱动器上的主引导记录（MBR）加载第一个扇区。

正如教程“学习Linux 101：硬盘布局”中所讨论的那样，MBR还包含分区表，因此MBR中的可执行代码量小于512字节，这不是很多代码。每个磁盘，甚至是软盘，都在其MBR中包含可执行代码，即使代码仅足以发出诸如“驱动器A中的不可引导磁盘：”之类的消息。 BIOS从第一个扇区加载的代码称为第一阶段引导加载程序或第1阶段引导加载程序。

MS DOS，PC DOS和Windows操作系统使用的标准硬盘驱动器MBR检查分区表以查找引导驱动器上标记为活动的主分区，从该分区加载第一个扇区，并将控制权交给开头加载的代码。这段新代码也称为分区引导记录。分区引导记录实际上是另一个第1阶段引导加载程序，但是这个具有足够的智能来从分区加载一组块。这组新块中的代码称为stage 2引导加载程序。由MS-DOS和PC-DOS使用，阶段2加载器直接进行加载其余的操作系统。这就是您的操作系统在启动和运行之前通过其自举启动的方式。

这适用于具有单个操作系统的系统。如果你想要多个操作系统，比如OS / 2，Windows XP和三种不同的Linux发行版，会发生什么？您可以使用某些程序（例如DOS FDISK程序）来更改活动分区并重新启动。这很麻烦。此外，磁盘只能有四个主分区，标准MBR只能有一个活动的主分区;它无法从逻辑分区启动。但我们假设的例子引用了五个操作系统，每个操作系统都需要一个分区。哎呀！

解决方案在于使用一些特殊代码，允许用户选择要引导的操作系统。例子包括：

**Loadlin**
从正在运行的DOS系统调用以引导Linux分区的DOS可执行程序。 当设置多重引导系统是一个复杂且有风险的过程时，这很受欢迎。

**OS/2 Boot Manager**
安装在小型专用分区中的程序。 该分区标记为活动，标准MBR引导过程启动OS / 2引导管理器，该管理器提供一个菜单，您可以在其中选择要引导的操作系统。

**A smart boot loader**
可驻留在操作系统分区上的程序，由活动分区的分区引导记录或主引导记录调用。 例子包括：

- BootMagic，Norton PartitionMagic的一部分
- LILO, the LInux LOader
- GRUB，GRand统一引导加载程序（现在称为GRUB Legacy）
- GRUB 2，一种较新的引导加载程序，现在用于许多常见的发行版中
- Syslinux，一组用于MS-DOS FAT文件系统（SYSLINUX）的轻量级引导加载程序，网络引导（PXELINUX），可引导的“El Torito”CD-ROM（ISOLINUX）和Linux ext2 / ext3 / ext4或btrfs文件系统（EXTLINUX）

显然，如果您可以将系统控制权交给某个程序，该程序具有超过512个字节的代码来完成其任务，那么允许从逻辑分区启动或从不在启动时的分区启动也不难。 所有这些解决方案都允许这些可能性，因为它们可以从任意分区加载引导记录，或者因为它们对要加载的文件或文件有一些了解以启动引导过程。

### 链式启动
当引导管理器获得控制权时，它可以加载的一件事是另一个引导管理器。 这称为链加载，最常发生在位于主引导记录（MBR）中的引导管理器加载分区引导记录中的引导加载程序时。 当Linux引导加载程序被要求引导Windows或DOS分区时，几乎总是这样做，但是当一个Linux系统的Linux引导加载程序（比如Fedora）被配置为加载另一个Linux系统的引导加载程序时，也可以这样做。 （比如Ubuntu）。 例如，您可以在一个分区中使用GRUB在另一个分区的引导记录中启动GRUB引导加载程序，以启动该分区中的Linux系统。 这并不常见，但它说明了可能性。

### Linux启动引导
本教程重点介绍GRUB，GRUB 2和LILO，因为这些是大多数Linux发行版中包含的引导加载程序。 LILO已经存在了一段时间。 GRUB比较新。原始GRUB现已成为GRUB Legacy，GRUB 2正在自由软件基金会的支持下开发（详见相关主题）。本教程首先讨论GRUB，然后讨论GRUB 2，以便您了解主要差异以及GRUB和GRUB 2如何共存。对于本教程的其余部分，假设GRUB表示GRUB Legacy，除非上下文特别指示GRUB 2.新版本的LILO称为ELILO（用于引导使用Intel的可扩展固件接口或EFI而不是BIOS的系统）也提供。有关ELILO的其他信息，请参阅参考资料。

如前所述，GRUB Legacy已不再处于活跃开发阶段，LILO开发计划于2015年底结束。2015年的大多数Linux系统都将GRUB 2作为默认设置，或者有时仅提供引导加载程序。

分发的安装过程可能会让您选择要设置的引导加载程序。 GRUB，GRUB 2和LILO都适用于大多数现代磁盘，尽管某些发行版，特别是Fedora，不再发布LILO或GRUB Legacy。请记住，磁盘技术已经快速发展，因此您应该始终确保所选的引导加载程序，以及您选择的Linux发行版（或其他操作系统）以及系统BIOS都可以使用闪亮的新磁盘。如果不这样做可能会导致数据丢失。同样，如果要将新分发添加到现有系统，则可能需要确保在MBR中具有最新的LILO，GRUB或GRUB 2。如果您计划从LVM或RAID磁盘启动，还需要一个相当新版本的启动加载程序。

使用LILO和GRUB中使用的第2阶段加载器，您可以选择要加载的多个操作系统或版本。但是，LILO和GRUB的不同之处在于，对系统的更改要求您在升级内核或对系统进行某些其他更改时使用命令重新创建LILO引导设置，而GRUB可以通过配置文本文件完成此操作你可以编辑。 GRUB 2还需要从通常存储在/ etc中的配置文件进行重建。

## GRUB
GRUB或GRand Unified Boot加载器长期以来一直是最常见的Linux引导加载程序之一。您可以将GRUB安装到可启动硬盘驱动器的MBR或分区的分区启动记录中。您也可以将其安装在可移动设备上，如软盘，CD或USB密钥。如果您还不熟悉GRUB，最好在软盘或USB密钥上练习。本教程中的示例向您展示了如何操作。

注意：本教程中的大多数GRUB示例都使用CentOS 6。

在Linux安装期间，您经常指定您选择的启动管理器。如果您选择LILO，那么您可能没有安装GRUB。如果您没有安装GRUB并且它可用于您的发行版，那么您需要为其安装软件包。本教程假定您已经安装了GRUB软件包。如果您需要帮助，请参阅有关包管理教程的系列路线图。

GRUB（Legacy）有一个配置文件，通常存储在/boot/grub/grub.conf中。如果您的文件系统支持符号链接，就像大多数Linux文件系统那样，您可能将/boot/grub/menu.lst作为/boot/grub/grub.conf的符号链接。

grub命令（/ sbin / grub，或者，在某些系统上，/ usr / sbin / grub）是一个小但功能相当强大的shell，它支持几个用于安装GRUB，引导系统，定位和显示配置文件以及类似任务的命令。这个shell与第二阶段GRUB引导加载程序共享很多代码，因此在不必引导到第二阶段GRUB环境的情况下了解GRUB很有用。 GRUB阶段2在菜单模式下运行，因此您可以从菜单或命令模式中选择操作系统，您可以在其中指定加载系统的各个命令。还有一些其他命令，例如grub-install，它们使用grub shell并帮助自动执行诸如安装GRUB之类的任务。

清单1显示了一个相当复杂的GRUB配置文件。当你仔细研究它时，请记住一件重要的事情：GRUB，至少GRUB Legacy，计算需要计算的驱动器，分区和事物，从0开始而不是1. CentOS的第二个条目有一个内核行非常长。清单1显示了一个反斜杠（\），表示它被中断以供发布。
```bash
# grub.conf generated by anaconda
#
# You do not have to rerun grub after making changes to this file
# NOTICE:  You do not have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /, eg.
#          root (hd0,5)
#          kernel /boot/vmlinuz-version ro root=/dev/hda6
#          initrd /boot/initrd-version.img
#boot=/dev/hda
default=0
timeout=60
splashimage=(hd0,0)/boot/grub/splash.xpm.gz
#password --md5 $1$y.uQRs1W$Sqs30hDB3GtE957PoiDWO.
 
title Fedora 22 64-bit (sda5)
    root (hd0,4)
        kernel /boot/grub2/i386-pc/core.img
 
title Fedora 18 64-bit (sda7)
    root (hd0,6)
        kernel /boot/grub2/i386-pc/core.img
 
title CentOS 6 64-bit (sda11)
        root (hd0,10)
        configfile /boot/grub/menu.lst
 
title CentOS (2.6.32-504.23.4.el6.x86_64)
    root (hd0,10)
    kernel /boot/vmlinuz-2.6.32-504.23.4.el6.x86_64 ro \
           root=UUID=2f60a3b4-ef6c-4d4c-9ef4-50d7f75124a2 rd_NO_LUKS rd_NO_LVM \
           LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=128M \
           KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /boot/initramfs-2.6.32-504.23.4.el6.x86_64.img
 
title Fedora 20 64-bit (sda10)
    root (hd0,9)
        configfile /boot/grub/menu.lst
 
title Ubuntu 12.04-LTS 64-bit (sda9)
    root (hd0,8)
        kernel /boot/grub/core.img
 
title Ubuntu 14.04 32-bit (sda12)
    root (hd0,11)
        kernel /boot/grub/core.img
 
title Slackware 13.37 64-bit (sda6)
    root (hd0,5)
        chainloader +1
        boot
     
title Open SUSE 11.4 64-bit (sda8)
    root (hd0,7)
        configfile /boot/grub/menu.lst
 
title Windows Example
    rootnoverify (hd0,0)
    chainloader +1
#####
```
清单1中的第一组选项控制GRUB的运行方式。 对于GRUB，这些称为菜单命令，它们必须出现在其他命令之前。 其余部分为您希望允许GRUB引导的操作系统提供每个映像选项。 “标题”被认为是菜单命令。 每个标题实例后跟一个或多个常规或菜单输入命令。
适用于清单1中所有其他部分的菜单命令是：
**#**
任何以＃开头的行都是注释，GRUB会忽略它。 此特定配置文件最初由anaconda（Red Hat安装程序）生成。 如果在安装Linux时安装GRUB，则可能会在GRUB配置文件中添加注释。 注释通常用作系统升级程序的辅助，以便您可以使用升级的内核保持GRUB配置的最新状态。 如果您自己编辑配置，请注意为此目的留下的任何标记。
**default**
如果用户未在超时内做出选择，则指定要加载的系统。 在清单1中，default = 0表示加载第一个条目。 请记住，GRUB从0开始计数而不是1.如果未指定，则默认为引导第一个条目，条目号0。
**timeout**
指定引导默认条目之前的超时（以秒为单位）。 请注意，LILO使用十分之一秒进行超时，而GRUB使用整秒。
**splashimage**
指定要与启动菜单一起显示的背景或启动图像。 GRUB Legacy将第一个硬盘驱动器称为（hd0），将该驱动器上的第一个分区称为（hd0,0），因此splashimage =（hd0,0）/boot/grub/splash.xpm.gz的规范意味着使用 文件/boot/grub/splash.xpm.gz位于第一个硬盘的分区1上。 记得从0开始计算。图像是用gzip压缩的XPM文件。 支持splashimage是一个可能包含或可能不包含在您的发行版中的补丁。
**password**
指定在解锁菜单并编辑配置行或输入GRUB命令之前必须输入的密码。 密码可以是明文。 GRUB还允许将密码存储为MD5摘要，如清单1中的注释示例所示。这更安全一些，大多数管理员都设置了密码。 没有密码，您可以完全访问GRUB命令行。
清单1显示了/ dev / sda11（hd0,10）上的CentOS内核/boot/vmlinuz-2.6.32-504.23.4.el6.x86_64，以及几个配置为链加载的系统。 清单1还提供了通过/boot/grub2/i386-pc/core.img加载GRUB 2的示例以及典型Windows XP链加载条目的示例，尽管此系统实际上并未安装Windows。 这些部分中使用的命令是：
**title**
是一个描述性标题，在Grub引导时显示为菜单项。 使用箭头键在标题列表中上下移动，然后按Enter键选择特定条目。
**root**
指定将引导的分区。 与splashimage一样，请记住计数从0开始，因此指定为root（hd0,6）的第一个Red Hat系统实际上位于第一个硬盘驱动器的分区7（在本例中为/ dev / hda7），而第一个 Ubuntu系统，指定为root（hd1,10），位于第二个硬盘驱动器（/ dev / hdb11）上。 GRUB尝试装入此分区以检查它，并在某些情况下为引导的操作系统提供值。
**kernel**
指定要加载的内核映像和任何所需的内核参数。 像/boot/grub2/i386-pc/core.img这样的内核值通常意味着从命名的根分区加载GRUB 2引导加载程序。
**initrd**
是初始RAM磁盘的名称，它包含在装入文件系统之前内核所需的模块。
**savedefault**
在此示例中未使用。 如果指定了菜单命令default = saved并且为操作系统指定了savedefault命令，则在引导另一个指定了savedefault的操作系统之前，引导该操作系统会使其成为默认值。 在清单1中，default = 0的规范会覆盖任何保存的默认值。
**boot**
是一个可选参数，指示GRUB引导所选操作系统。 这是处理选择的所有命令时的默认操作。
**lock**
清单1中未使用。在输入密码之前，这不会引导指定的条目。 如果您使用它，那么您还应该在初始选项中指定密码; 否则，用户可以编辑您的锁定选项并启动系统或将“单个”添加到其他条目之一。 如果需要，可以为各个条目指定不同的密码。
**rootnoverify**
与root类似，不同之处在于GRUB不会尝试装入文件系统或验证其参数。 这通常用于GRUB不支持的文件系统，如NTFS。 如果希望GRUB在硬盘驱动器上加载主引导记录（例如，访问其他配置文件或重新加载以前的引导加载程序），也可以使用此方法。
**chainloader**
指定将另一个文件作为stage 1文件加载。 值“+1”相当于0 + 1，这意味着从扇区0开始加载一个扇区; 也就是说，从root或rootnoverify指定的设备加载第一个扇区。
**configfile**
指定GRUB的运行副本使用从目标位置加载的一个替换其配置文件。 为此，建议加载新配置文件的GRUB版本与构建它的版本一样。
您现在已经了解了在典型的/boot/grub/grub.conf（或/boot/grub/menu.lst）文件中可能会发现的内容。 还有许多其他GRUB命令可以提供对引导过程的广泛控制，以及帮助安装GRUB和其他任务。 您可以在GRUB手册中了解有关这些内容的更多信息，该手册应通过命令info grub在您的系统上提供。

在您学习如何处理如此大的GRUB配置文件之前，让我们回到一个更小更简单的示例。 我在/ dev / sda11上安装时使用了CentOS 6为我构建的文件。 清单2中显示了这一点。同样，我们使用反斜杠（\）来显示我们打破长内核行以供发布的位置。

```shell
# grub.conf generated by anaconda
#
# You do not have to rerun grub after making changes to this file
# NOTICE:  You do not have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /, eg.
#          root (hd0,10)
#          kernel /boot/vmlinuz-version ro root=/dev/sdd11
#          initrd /boot/initrd-[generic-]version.img
#boot=/dev/sdd11
default=0
timeout=5
splashimage=(hd0,10)/boot/grub/splash.xpm.gz
hiddenmenu
title CentOS (2.6.32-504.23.4.el6.x86_64)
    root (hd0,10)
    kernel /boot/vmlinuz-2.6.32-504.23.4.el6.x86_64 ro \
           root=UUID=2f60a3b4-ef6c-4d4c-9ef4-50d7f75124a2 rd_NO_LUKS rd_NO_LVM \
           LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=128M \
           KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /boot/initramfs-2.6.32-504.23.4.el6.x86_64.img
title CentOS 6 (2.6.32-504.el6.x86_64)
    root (hd0,10)
    kernel /boot/vmlinuz-2.6.32-504.el6.x86_64 ro \
           root=UUID=2f60a3b4-ef6c-4d4c-9ef4-50d7f75124a2 rd_NO_LUKS rd_NO_LVM \
           LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=128M \
           KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /boot/initramfs-2.6.32-504.el6.x86_64.img
title Other
    rootnoverify (hd0,0)
    chainloader +1
```
注意你之前没有看到的命令hiddenmenu。这会导致GRUB不显示菜单，而是在超时到期后立即引导默认条目。在我们的例子中，这意味着第一个条目（默认值= 0）将在5秒内启动（超时= 5）。如果在此期间按Enter键，将显示菜单。

拥有GRUB配置文件后，您需要安装它，或者最好测试它。我将首先向您展示如何进行安装，然后向您展示如何使用软盘驱动器（如果您还有）或CD进行测试。

我将GRUB安装在包含我的CentOS发行版的分区的分区引导记录中。我使用grub-install命令并指定512字节stage1引导加载程序应该去的设备。在我的例子中，那是使用GRUB表示法的/ dev / sda11或（hd0,10）。请参见清单3.您需要具有root权限才能编写分区引导记录。如果您添加或删除了设备，则可能必须删除/boot/grub/device.map文件并允许重建grub-install，如我们的示例所示。这不会经常发生，但如果grub-install引发了一些您不理解的奇怪错误，您可能会发现删除device.map文件很有帮助。
```shell
[root@attic4-cent ~]# rm /boot/grub/device.map 
rm: remove regular file `/boot/grub/device.map'? y
[root@attic4-cent ~]# grub-install /dev/sda11
Probing devices to guess BIOS drives. This might take a long time.
Installation finished. No error reported.
This is the contents of the device map /boot/grub/device.map.
Check if this is correct or not. If any of the lines is incorrect,
fix it and re-run the script `grub-install'.
 
(fd0)   /dev/fd0
(hd0)   /dev/sda
(hd1)   /dev/sdb
(hd2)   /dev/sdc
(hd3)   /dev/sdd
```
正如您已经了解到的那样，标准DOS MBR无法启动逻辑分区，因此您需要其他东西来启动此系统。 一种选择是通过执行grub-install / dev / sda在MBR中安装GRUB，这也会将GRUB安装在我们磁盘的MBR中（/ dev / sda）。 我还将在稍后向您展示如何使用GRUB 2，但在您提交任一方法步骤之前，您可能希望使用GRUB引导CD测试您的设置。

### 制作一个可用grub启动的救援CD
在重新启动闪亮的新系统之前，构建可引导的GRUB CD可能是个好主意。 首先，在硬盘上准备一张CD映像。 你需要一个临时目录，比如grubcd，子目录boot和boot / grub。 然后，您需要将stage2_eltorito文件从GRUB分发文件复制到刚刚创建的grub子目录。 然后，使用genisoimage创建可引导的.iso映像文件，您可以使用自己喜欢的刻录工具将其刻录到CD。 清单4显示了如何将CD映像创建为grubcd.iso。 您不需要root权限来执行此操作。 我们的stage2_eltorito位于/ usr / share / grub / x86_64-redhat中。 此位置在其他系统上可能不同，尤其是32位系统。 或者，您可以在/ usr / lib / grub下找到它。 您可以使用locate命令找到它，如清单4所示。
```shell
[ian@attic4-cent ~]$ mkdir mkdir -p grubcd/boot/grub
[ian@attic4-cent ~]$ ls /usr/share/grub/
x86_64-redhat
[ian@attic4-cent ~]$ ls /usr/share/grub/x86_64-redhat/stage2_eltorito
/usr/share/grub/x86_64-redhat/stage2_eltorito
[ian@attic4-cent ~]$ locate stage2_eltorito
/usr/share/grub/x86_64-redhat/stage2_eltorito
[ian@attic4-cent ~]$ cp /usr/share/grub/x86_64-redhat/stage2_eltorito grubcd/boot/grub
[ian@attic4-cent ~]$ genisoimage -R -b boot/grub/stage2_eltorito -no-emul-boot \
> -boot-load-size 4 -boot-info-table -o grubcd.iso grubcd
I: -input-charset not specified, using utf-8 (detected in locale settings)
Size of boot image is 4 sectors -> No emulation
Total translation table size: 2048
Total rockridge attributes bytes: 760
Total directory bytes: 4576
Path table size(bytes): 34
Max brk space used 22000
241 extents written (0 MB)
```
您可以在任意PC中启动此CD;它不一定是一个Linux系统。如果您启动CD，它将从CD加载GRUB shell。启动时，会收到GRUB引导提示。按tab键或使用help命令查看可用的命令列表。尝试使用help commandname获取名为commandname的命令的帮助。

在使用CD重启之前的最后一件事：您可以从Linux命令行练习GRUB shell中可用的一些GRUB命令。清单5展示了grub命令和一些可用的命令，包括显示菜单并查看它是否是您想要的功能。某些命令（如find）需要root权限，因此我的示例使用了该权限。另请注意，当您尝试按Enter键加载第一个配置条目时，GRUB会因分段错误而崩溃。请记住，您可以从Bash命令行练习一些GRUB shell命令，但不是全部。向上和向下箭头键可能也不起作用。同样，使用\来分割长内核行。
```shell
[root@attic4-cent ~]# grub
Probing devices to guess BIOS drives. This might take a long time.
 
 
    GNU GRUB  version 0.97  (640K lower / 3072K upper memory)
 
 [ Minimal BASH-like line editing is supported.  For the first word, TAB
   lists possible command completions.  Anywhere else TAB lists the possible
   completions of a device/filename.]
grub> help rootnoverify
help rootnoverify
rootnoverify: rootnoverify [DEVICE [HDBIAS]]
    Similar to `root', but don't attempt to mount the partition. This 
    is useful for when an OS is outside of the area of the disk that 
    GRUB can read, but setting the correct root device is still 
    desired. The items mentioned in `root' which derived 
    from attempting the mount will NOT work correctly.
grub> find /boot/grub/menu.lst
find /boot/grub/menu.lst
 (hd0,0)
 (hd0,7)
 (hd0,10)
grub> configfile (hd0,10)/boot/grub/menu.lst
configfile (hd0,10)/boot/grub/menu.lst
 
Press any key to enter the menu
 
 
    GNU GRUB  version 0.97  (640K lower / 3072K upper memory)
 
-------------------------------------------------------------------
 0: CentOS (2.6.32-504.23.4.el6.x86_64)
 1: CentOS 6 (2.6.32-504.el6.x86_64)
 2: Other
-------------------------------------------------------------------
 
      Use the ^ and v keys to select which entry is highlighted.
      Press enter to boot the selected OS, 'e' to edit the
      commands before booting, 'a' to modify the kernel arguments
      before booting, or 'c' for a command-line.
 
The selected entry is 0     Highlighted entry is 0: 
 
  Booting 'CentOS (2.6.32-504.23.4.el6.x86_64)'
 
root (hd0,10)
 Filesystem type is ext2fs, partition type 0x83
kernel /boot/vmlinuz-2.6.32-504.23.4.el6.x86_64 ro \
root=UUID=2f60a3b4-ef6c-4d4c-9ef4-50d7f75124a2 rd_NO_LUKS rd_NO_LVM \
LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=128M  \
KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
   [Linux-bzImage, setup=0x3400, size=0x3f2790]
Segmentation fault (core dumped)
```
在此示例中，第一个硬盘驱动器上的三个不同分区上有GRUB配置文件，包括为（hd0,10）或/ dev / sda11上的CentOS构建的文件。 清单5使用configfile命令从（hd0,10）加载GRUB菜单。
您可以在GRUB手册中浏览这些grub命令。 尝试在Linux终端窗口中键入info grub以打开手册。
如果您还有软盘，可以使用如下命令在软盘上安装GRUB
```shell
grub-install /dev/fd0
```
，其中/ dev / fd0对应于您的软盘驱动器。 您应该在安装GRUB之前卸载软盘。

### 使用GRUB legacy引导
现在，您已准备好使用刚刚构建的GRUB CD重新启动系统。 如果您的BIOS未设置为从CD或DVD自动启动（如果存在），则可能需要按某个系统专用密钥（我的BIOS上的F8）来选择除硬盘驱动器之外的启动设备。 CD将引导至GRUB提示符，如图1所示。
![此处输入图片的描述][1]
在这个例子中，我使用find命令查找名为menu.lst的GRUB配置文件并找到3，包括设备（hd0,10）或/ dev / sda11上的CentOS GRUB配置文件。 然后我使用root命令设置（hd0,10）作为进一步文件操作的根。 我在（hd0,10）的分区引导记录中安装了GRUB，所以我使用chainloader命令告诉grub引导（hd0,10）的第一个扇区中的任何引导加载程序。 最后，我使用boot命令来引导这个新的加载器（在我们的例子中再次使用GRUB）。 结果如图2所示
![此处输入图片的描述][2]
在这种情况下，按Enter键查看菜单。 否则隐藏菜单选项只显示正在启动的行和倒数计时器。

### 在GRUB shell中进行编辑
现在，我将向您展示如何使用GRUB shell编辑配置。 为此，您将以单用户模式启动，但您可以更改任何行，甚至可以根据需要添加或删除整个配置行。 例如，如果您忘记了root行，则可以添加完整root行。 按e编辑配置，然后使用向下箭头高亮内核行。 结果如图3所示。
![此处输入图片的描述][3]
再次按e，然后在该行的末尾键入单词single，如图4所示。
![此处输入图片的描述][4]
最后，按Enter返回到图2中显示的屏幕，然后按b将CentOS引导到单用户模式。 系统引导时，您将有一个根提示符。 您可以使用此模式对无法正常启动的系统进行紧急修复。

此时，您可以重复上一个过程以启动到正常的图形模式或您设置系统引导的任何模式。 如果您希望GRUB控制系统上的所有引导，您现在可以
grub-install / dev / sda
在/ dev / sda的MBR中安装GRUB。 在本教程中，您将看到管理引导的其他方法。

## GRUB 2
GRUB 2是GRUB的继承者。它从头开始重写，使其更加模块化和便携。它针对不同的体系结构和引导方法，并具有许多新功能，包括处理UEFI固件和GPT格式化驱动器的能力。有关详细信息，请参阅参考资料。如果您熟悉GRUB并开始使用GRUB 2，您会发现它完全不同，您可能会收到许多惊喜。

注意：本教程中的大多数GRUB 2示例都使用Fedora 22或Ubuntu 15。

您可能会注意到GRUB 2的第一件事是它不作为分区引导加载程序安装。如果您告诉Linux安装程序在分区中安装GRUB，则该分区不能通过链式加载来引导。更新系统时必须重建GRUB 2。大多数系统更新过程都会为您处理，但如果系统上有多个操作系统，您可能需要自己完成一些工作。现在，我将向您展示如何单独使用GRUB 2或与GRUB Legacy一起使用GRUB 2。

GRUB 2包中包含多个程序，通常位于/ usr / bin或/ usr / sbin中。实际包名称随时间而变化，并且对于所有分发都不相同。二进制文件的名称通常以grub-或grub2-开头。例如，在Ubuntu 14上，您将找到由grub-common包提供的grub-image，而在Fedora 22上，您将找到由grub2-tools包提供的grub2-mkimage。请参阅学习Linux，101：Debian软件包管理和学习Linux，101：RPM和YUM软件包管理，以获取有关查找包含特定命令的软件包的帮助。清单6显示了Ubuntu 14.04系统上的Grub二进制文件。像往常一样，请查阅手册页或尝试使用--help选项运行程序以获取更多信息。您可能需要在Internet上搜索其他帮助。当事情变化如此之快时，请准备好文档中的不一致。
```shell
ian@attic-u14:~$ which grub-image
/usr/bin/grub-image
ian@attic-u14:~$ dpkg -S /usr/bin/grub-image
grub-common: /usr/bin/grub-image
ian@attic-u14:~$ dpkg -L grub-common | grep "bin/"
/usr/sbin/grub-mkdevicemap
/usr/sbin/grub-mkconfig
/usr/sbin/grub-probe
/usr/sbin/grub-macbless
/usr/bin/grub-glue-efi
/usr/bin/grub-mkfont
/usr/bin/grub-script-check
/usr/bin/grub-fstest
/usr/bin/grub-mkstandalone
/usr/bin/grub-image
/usr/bin/grub-mklayout
/usr/bin/grub-mkrescue
/usr/bin/grub-mkrelpath
/usr/bin/grub-kbdcomp
/usr/bin/grub-render-label
/usr/bin/grub-mount
/usr/bin/grub-file
/usr/bin/grub-menulst2cfg
/usr/bin/grub-editenv
/usr/bin/grub-syslinux2cfg
/usr/bin/grub-mkpasswd-pbkdf2
/usr/bin/grub-mknetdir
```
GRUB 2的核心是一个多引导内核（/boot/grub/core.img）以及一个配置文件（/boot/grub/grub.cfg）。 如果您运行grub-install并将目标设置为MBR（例如：grub-install / dev / sda），将为您生成这些内容。 运行grub-install --help，如清单7所示，以了解被调用以完成所有工作的程序。 有些东西类似于Grub Legacy，但是有很多新项目，例如--modules， --grub-setup， --grub-image等等。
```shell
ian@attic-u14:~$ grub-install --help
Usage: grub-install [OPTION...] [OPTION] [INSTALL_DEVICE]
Install GRUB on your drive.
 
      --compress[=no,xz,gz,lzo]   compress GRUB files [optional]
  -d, --directory=DIR        use images and modules under DIR
                             [default=/usr/lib/grub/<platform>]
      --fonts=FONTS          install FONTS [default=unicode]
      --install-modules=MODULES   install only MODULES and their dependencies
                             [default=all]
  -k, --pubkey=FILE          embed FILE as public key for signature checking
      --locale-directory=DIR use translations under DIR
                             [default=/usr/share/locale]
      --locales=LOCALES      install only LOCALES [default=all]
      --modules=MODULES      pre-load specified modules MODULES
      --themes=THEMES        install THEMES [default=starfield]
  -v, --verbose              print verbose messages.
      --allow-floppy         make the drive also bootable as floppy (default
                             for fdX devices). May break on some BIOSes.
      --boot-directory=DIR   install GRUB images under the directory DIR/grub
                             instead of the boot/grub directory
      --bootloader-id=ID     the ID of bootloader. This option is only
                             available on EFI and Macs.
      --core-compress=xz|none|auto
                             choose the compression to use for core image
      --disk-module=MODULE   disk module to use (biosdisk or native). This
                             option is only available on BIOS target.
      --efi-directory=DIR    use DIR as the EFI System Partition root.
      --force                install even if problems are detected
      --force-file-id        use identifier file even if UUID is available
      --label-bgcolor=COLOR  use COLOR for label background
      --label-color=COLOR    use COLOR for label
      --label-font=FILE      use FILE as font for label
      --macppc-directory=DIR use DIR for PPC MAC install.
      --no-bootsector        do not install bootsector
      --no-nvram             don't update the `boot-device'/`Boot*' NVRAM
                             variables. This option is only available on EFI
                             and IEEE1275 targets.
      --no-rs-codes          Do not apply any reed-solomon codes when
                             embedding core.img. This option is only available
                             on x86 BIOS targets.
      --no-uefi-secure-boot  do not install an image usable with UEFI Secure
                             Boot, even if the system was currently started
                             using it. This option is only available on EFI.
      --product-version=STRING   use STRING as product version
      --recheck              delete device map if it already exists
      --removable            the installation device is removable. This option
                             is only available on EFI.
  -s, --skip-fs-probe        do not probe for filesystems in DEVICE
      --target=TARGET        install GRUB for TARGET platform
                             [default=i386-pc]
      --uefi-secure-boot     install an image usable with UEFI Secure Boot.
                             This option is only available on EFI and if the
                             grub-efi-amd64-signed package is installed.
  -?, --help                 give this help list
      --usage                give a short usage message
  -V, --version              print program version
 
Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.
 
INSTALL_DEVICE must be system device filename.
grub-install copies GRUB images into boot/grub.  On some platforms, it may
also install GRUB into the boot sector.
 
Report bugs to <bug-grub@gnu.org>.
```
如果运行grub-install / dev / sda，该进程将为您构建核心映像文件，构建配置文件，并在MBR中安装GRUB 2。 如果您还没准备好为整个设置提交GRUB 2，您可以自己构建这些部件，然后从GRUB Legacy或LILO引导GRUB 2核心映像。

### 创建grub2配置文件
GRUB 2配置文件通常是/boot/grub/grub.cfg。与GRUB Legacy不同，您通常不应自行编辑此文件，因为下次更新GRUB 2时它将被覆盖。你应该使用grub-mkconfig构建它。在某些系统上，例如Ubuntu，update-grub命令是grub-mkconfig的前端，它将其输出保存在/boot/grub/grub.cfg中。这些命令在/ etc / default / grub中查找常规设置（例如后台或超时），然后从/etc/grub.d/运行可执行文件以构建配置文件的各个部分，例如标题，一个部分用于当前的Linux发行版，其他操作系统的各个部分以及您自己的自定义附加内容。如果需要自定义GRUB 2菜单，可以将更改添加到/etc/grub.d/中的文件（如40_custom），或添加自己的文件。请记住，它需要是可执行的。当我向您展示如何从GRUB 2链接加载GRUB legacy时，我向您展示了一个自定义示例。

运行grub-mkconfig（或update-grub，如果可用）生成新的/boot/grub/grub.cfg文件，如清单8所示。

```shell
ian@attic-u14:~$ sudo grub-mkconfig -o /boot/grub/grub.cfg
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-3.16.0-43-generic
Found initrd image: /boot/initrd.img-3.16.0-43-generic
Found linux image: /boot/vmlinuz-3.16.0-30-generic
Found initrd image: /boot/initrd.img-3.16.0-30-generic
Found memtest86+ image: /boot/memtest86+.elf
Found memtest86+ image: /boot/memtest86+.bin
Found Fedora release 20 (Heisenbug) on /dev/sda10
Found CentOS release 6.6 (Final) on /dev/sda11
Found Fedora release 22 (Twenty Two) on /dev/sda5
Found Slackware Linux (Slackware 13.37.0) on /dev/sda6
Found Fedora release 18 (Spherical Cow) on /dev/sda7
Found openSUSE 11.4 (x86_64) on /dev/sda8
Found Ubuntu 12.04 LTS (12.04) on /dev/sda9
done
```
清单9显示了生成的配置文件的标题部分，清单10显示了前几个菜单条目。 我已经指出了使用尾部反斜杠（\）打破发布的长行。 请注意，menuentry节看起来更像是shell脚本而不是没有GRUB Legacy逻辑的普通命令。 GRUB Legacy的另一个重要变化是分区编号现在从1开始，尽管磁盘编号仍然从0开始。因此/ dev / sda7在GRUB 2中是（hd0,7），它在GRUB Legacy中是（hd0.6）。 GRUB 2还可以使用可选的分区名称和数字。 所以（hd0,7）也可以称为（hd0，msdos7），以明确它是在MBR格式的磁盘上。 在GPT格式的磁盘上，您将使用（hd0，gpt7）。

```shell
#
# DO NOT EDIT THIS FILE
#
# It is automatically generated by grub-mkconfig using templates
# from /etc/grub.d and settings from /etc/default/grub
#
 
### BEGIN /etc/grub.d/00_header ###
if [ -s $prefix/grubenv ]; then
  set have_grubenv=true
  load_env
fi
if [ "${next_entry}" ] ; then
   set default="${next_entry}"
   set next_entry=
   save_env next_entry
   set boot_once=true
else
   set default="0"
fi
 
if [ x"${feature_menuentry_id}" = xy ]; then
  menuentry_id_option="--id"
else
  menuentry_id_option=""
fi
 
export menuentry_id_option
 
if [ "${prev_saved_entry}" ]; then
  set saved_entry="${prev_saved_entry}"
  save_env saved_entry
  set prev_saved_entry=
  save_env prev_saved_entry
  set boot_once=true
fi
 
function savedefault {
  if [ -z "${boot_once}" ]; then
    saved_entry="${chosen}"
    save_env saved_entry
  fi
}
function recordfail {
  set recordfail=1
  if [ -n "${have_grubenv}" ]; then if [ -z "${boot_once}" ]; then save_env recordfail; fi; fi
}
function load_video {
  if [ x$feature_all_video_module = xy ]; then
    insmod all_video
  else
    insmod efi_gop
    insmod efi_uga
    insmod ieee1275_fb
    insmod vbe
    insmod vga
    insmod video_bochs
    insmod video_cirrus
  fi
}
 
if [ x$feature_default_font_path = xy ] ; then
   font=unicode
else
insmod part_msdos
insmod ext2
set root='hd0,msdos12'
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos12 --hint-efi=hd0,msdos12 \
    --hint-baremetal=ahci0,msdos12  943524cc-19a9-4237-ac9e-5c1a61a131e3
else
  search --no-floppy --fs-uuid --set=root 943524cc-19a9-4237-ac9e-5c1a61a131e3
fi
    font="/usr/share/grub/unicode.pf2"
fi
 
if loadfont $font ; then
  set gfxmode=auto
  load_video
  insmod gfxterm
  set locale_dir=$prefix/locale
  set lang=en_US
  insmod gettext
fi
terminal_output gfxterm
if [ "${recordfail}" = 1 ] ; then
  set timeout=30
else
  if [ x$feature_timeout_style = xy ] ; then
    set timeout_style=menu
    set timeout=60
  # Fallback normal timeout code in case the timeout_style feature is
  # unavailable.
  else
    set timeout=60
  fi
fi
### END /etc/grub.d/00_header ###
```

```shell
### BEGIN /etc/grub.d/10_linux ###
function gfxmode {
    set gfxpayload="${1}"
    if [ "${1}" = "keep" ]; then
        set vt_handoff=vt.handoff=7
    else
        set vt_handoff=
    fi
}
if [ "${recordfail}" != 1 ]; then
  if [ -e ${prefix}/gfxblacklist.txt ]; then
    if hwmatch ${prefix}/gfxblacklist.txt 3; then
      if [ ${match} = 0 ]; then
        set linux_gfx_mode=keep
      else
        set linux_gfx_mode=text
      fi
    else
      set linux_gfx_mode=text
    fi
  else
    set linux_gfx_mode=keep
  fi
else
  set linux_gfx_mode=text
fi
export linux_gfx_mode
menuentry 'Ubuntu' --class ubuntu --class gnu-linux --class gnu \
    --class os $menuentry_id_option \
    'gnulinux-simple-943524cc-19a9-4237-ac9e-5c1a61a131e3' {
    recordfail
    load_video
    gfxmode $linux_gfx_mode
    insmod gzio
    insmod part_msdos
    insmod ext2
    set root='hd0,msdos12'
    if [ x$feature_platform_search_hint = xy ]; then
      search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos12 \
       --hint-efi=hd0,msdos12 --hint-baremetal=ahci0,msdos12  ]
       943524cc-19a9-4237-ac9e-5c1a61a131e3
    else
      search --no-floppy --fs-uuid --set=root 943524cc-19a9-4237-ac9e-5c1a61a131e3
    fi
    linux   /boot/vmlinuz-3.16.0-43-generic root=UUID=943524cc-19a9-4237-ac9e-5c1a61a131e3 \
        ro quiet splash $vt_handoff
    initrd  /boot/initrd.img-3.16.0-43-generic
}
submenu 'Advanced options for Ubuntu' $menuentry_id_option \
    'gnulinux-advanced-943524cc-19a9-4237-ac9e-5c1a61a131e3' {
    menuentry 'Ubuntu, with Linux 3.16.0-43-generic' --class ubuntu \
     --class gnu-linux --class gnu --class os $menuentry_id_option \
     'gnulinux-3.16.0-43-generic-advanced-943524cc-19a9-4237-ac9e-5c1a61a131e3' {
        recordfail
        load_video
        gfxmode $linux_gfx_mode
        insmod gzio
        insmod part_msdos
        insmod ext2
        set root='hd0,msdos12'
        if [ x$feature_platform_search_hint = xy ]; then
          search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos12 \
          --hint-efi=hd0,msdos12 --hint-baremetal=ahci0,msdos12  \
          943524cc-19a9-4237-ac9e-5c1a61a131e3
        else
          search --no-floppy --fs-uuid --set=root 943524cc-19a9-4237-ac9e-5c1a61a131e3
        fi
        echo    'Loading Linux 3.16.0-43-generic ...'
        linux   /boot/vmlinuz-3.16.0-43-generic \
          root=UUID=943524cc-19a9-4237-ac9e-5c1a61a131e3 ro quiet splash $vt_handoff
        echo    'Loading initial ramdisk ...'
        initrd  /boot/initrd.img-3.16.0-43-generic
    }
    menuentry 'Ubuntu, with Linux 3.16.0-43-generic (recovery mode)' --class ubuntu \
     --class gnu-linux --class gnu --class os $menuentry_id_option \
     'gnulinux-3.16.0-43-generic-recovery-943524cc-19a9-4237-ac9e-5c1a61a131e3' {
        recordfail
        load_video
        insmod gzio
        insmod part_msdos
        insmod ext2
        set root='hd0,msdos12'
        if [ x$feature_platform_search_hint = xy ]; then
          search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos12 \
         --hinter=hd0,msdos12--bargain-basement=ahci0,msdos12  \
          943524cc-19a9-4237-ac9e-5c1a61a131e3
        else
          search--no-floppy--fluidised--set=root 943524cc-19a9-4237-ac9e-5c1a61a131e3
        phi
        echo    'Loading Linux 3.16.0-43-generic..'
        Linux   /boot/vmlinuz-3.16.0-43-generic \
                root=UUID=943524cc-19a9-4237-ac9e-5c1a61a131e3 or \
                recovery Modesto 
        echo    'Loading initial ram disk..'
        initrd  /boot/initrd.img-3.16.0-43-generic
    }
    menu entry 'Ubuntu, with Linux 3.16.0-30-generic'--class Ubuntu \
        --class Linux--class gnu--class OS $menu entry_id_option \
         'gnulinux-3.16.0-30-generic-advanced-943524cc-19a9-4237-ac9e-5c1a61a131e3' {
        record fail
        load_video
        modem $Linux_GIF_mode
        ins mod Zion
        ins mod part_ms dos
        ins mod ext2
        set root='hd0,msdos12'
        if [ x$feature_platform_search_hint = x ]; then
          search--no-floppy--fluidised--set=root--hint-bios=hd0,msdos12 \
         --hinter=hd0,msdos12--bargain-basement=ahci0,msdos12  \
          943524cc-19a9-4237-ac9e-5c1a61a131e3
        else
          search--no-floppy--fluidised--set=root 943524cc-19a9-4237-ac9e-5c1a61a131e3
        phi
        echo    'Loading Linux 3.16.0-30-generic..'
        Linux   /boot/vmlinuz-3.16.0-30-generic \
                root=UUID=943524cc-19a9-4237-ac9e-5c1a61a131e3 \
                or quiet splash $VT_hand off
        echo    'Loading initial ram disk..'
        initrd  /boot/initrd.img-3.16.0-30-generic
    }
    menu entry 'Ubuntu, with Linux 3.16.0-30-generic (recovery mode)'--class Ubuntu \
         --class Linux--class gnu--class OS $menu entry_id_option \
          'gnulinux-3.16.0-30-generic-recovery-943524cc-19a9-4237-ac9e-5c1a61a131e3' {
        record fail
        load_video
        ins mod Zion
        ins mod part_ms dos
        ins mod ext2
        set root='hd0,msdos12'
        if [ x$feature_platform_search_hint = x ]; then
          search--no-floppy--fluidised--set=root--hint-bios=hd0,msdos12 \
         --hinter=hd0,msdos12--bargain-basement=ahci0,msdos12  \
          943524cc-19a9-4237-ac9e-5c1a61a131e3
        else
          search--no-floppy--fluidised--set=root 943524cc-19a9-4237-ac9e-5c1a61a131e3
        phi
        echo    'Loading Linux 3.16.0-30-generic..'
        Linux   /boot/vmlinuz-3.16.0-30-generic \
                root=UUID=943524cc-19a9-4237-ac9e-5c1a61a131e3 \
                or recovery Modesto 
        echo    'Loading initial ram disk..'
        initrd  /boot/initrd.img-3.16.0-30-generic
    }
}
 
### END /etc/grub.d/10_Linux ###
```

### 构建GRUB 2核心像镜
构建新核心映像文件的最简单方法是运行grub-install（或根据您的系统安装grub2-install），但不要更新MBR。 某些版本的程序使用-grub-setup选项安装引导扇区，以指示实际设置的程序。 将此设置为/ bin / true不执行任何操作，从而避免引导扇区更新。 其他版本没有-grub-setup选项，而是使用-non-sectarian选项。 查看手册页。 我在清单11中展示了两个不同的示例。我首先删除现有的core.img以显示该文件确实已生成。
```shell
[root@atticf20 ~]# # Build a core.img file on Fedora 22
[root@atticf20 ~]# grub2-install --recheck --grub-setup=/bin/true /dev/sda
Installing for i386-pc platform.
Installation finished. No error reported.
[root@atticf20 ~]# ls -l /boot/grub2/i386-pc/core.img 
-rw-r--r--. 1 root root 25887 Jul 12 22:56 /boot/grub2/i386-pc/core.img
 
ian@attic-u14:~$ # Build a core.img file on Ubuntu 14
ian@attic-u14:~$ sudo grub-install --non-sectarian /dev/sda
[sudo] password for ian: 
Installing for i386-pc platform.
Installation finished. No error reported.
ian@attic-u14:~$ ls -l /boot/grub/i386-pc/core.img 
-rw-r--r-- 1 root root 25363 Jul 12 23:15 /boot/grub/i386-pc/core.img
```

### 构建可启动的GRUB2救援光盘
GRUB 2附带了grub-mkrescue或grub2-mkrescue命令，可帮助您创建救援CD映像。 最新版本的grub-mkrescue使用xorriso包而不是mkisofs包或genisoimage包来创建ISO映像，因此如果第一次尝试失败时需要安装，并显示错误消息，指出未找到Xorriso或处于错误级别。 清单12显示了如何在文件rescue.iso中创建GRUB 2救援映像。 您不必是root用户来创建救援ISO。
```shell
[root@echidna ~]# /usr/bin/grub2-mkrescue -o rescue.iso
Enabling BIOS support ...
xorriso 1.2.4 : RockRidge filesystem manipulator, libburnia project.
 
Drive current: -outdev 'stdio:rescue.iso'
Media current: stdio file, overwriteable
Media status : is blank
Media summary: 0 sessions, 0 data blocks, 0 data, 7177m free
Added to ISO image: directory '/'='/tmp/tmp.Dw4KSbpoIx'
xorriso : UPDATE : 196 files added in 1 seconds
xorriso : UPDATE : 196 files added in 1 seconds
xorriso : NOTE : Copying to System Area: 29191 bytes from file '/tmp/tmp.LepCeiJPZM'
ISO image produced: 1094 sectors
Written to medium : 1094 sectors at LBA 0
Writing to 'stdio:rescue.iso' completed successfully.
```
创建ISO映像后，可以使用自己喜欢的刻录工具将其刻录到CD（或DVD）。 如果您愿意，还可以将其复制到USB闪存驱动器并从中启动，假设您的BIOS支持从此类设备启动。 清单13显示了如何使用dd命令将ISO映像复制到USB闪存驱动器/ dev / sde。警告：确保将镜像复制到正确的设备。 将其复制到错误的设备可能会破坏大量数据。
```shell
ian@attic-u14:~$ # Burn .iso image to USB stick /dev/sde
ian@attic-u14:~$ sudo dd if=rescue.iso of=/dev/sde
9864+0 records in
9864+0 records out
5050368 bytes (5.1 MB) copied, 3.95946 s, 1.3 MB/s
```
您现在应该具有可引导CD或可引导USB闪存驱动器，它将引导至GRUB 2提示符。

### 使用GRUB引导
您将启动USB闪存驱动器以查看其工作原理。 与GRUB legacy一样，此救援磁盘将引导至GRUB提示符，您可以在其中输入命令。 我向您展示了一些可以用来启动我之前构建的配置文件的Ubuntu 14系统。 图5显示了启动并输入一些命令后的屏幕。
![此处输入图片的描述][5]
可以输入如下命令：
**ls**
没有参数，列出找到的设备。 这可能需要一些时间才能运行。 闪存驱动器通常不是BIOS驱动器，但如果从一个驱动器启动，它可能会显示为hd0并取代其他驱动器，导致它们不能按预期编号。 使用可引导CD或DVD可以避免此问题。
**set**
设置变量值。 在这种情况下，您可以设置根变量。 与GRUB legacy root命令比较。 您使用hd1而不是hd0，因为上一个命令告诉您hd0现在是您启动的USB闪存驱动器。
**ls**
使用路径，显示文件或目录。 使用类似Bash的选项卡完成来完成您正在键入的路径组件或获取可能的完成列表（如此处所示）（我在输入/ boot / grub / gru后按下了tab）。
**configfile**
与GRUB legacy一样，您可以使用configfile命令加载配置文件。 您加载之前构建的那个。

加载配置文件后，屏幕如图6所示。

![此处输入图片的描述][6]

### 从Grub Legacy引导GRUB 2，反之亦然
我提到你不能从分区引导记录链式加载GRUB 2。 构建核心映像和配置文件后，在GRUB Legacy grub.conf或menu.lst文件中添加一个条目以引导GRUB 2核心映像，然后显示您构建的GRUB 2菜单。 清单14显示了我在清单1中使用的/ dev / sda12上的Ubuntu 14安装的条目。由于此配置文件用于GRUB Legacy，因此根条目为/ dev / sda12指定（hd0,11）。
```shell
title Ubuntu 14.04 32-bit (sda12)
    root (hd0,11)
        kernel /boot/grub/core.img
```
同样，您可以在GRUB 2配置文件中添加一个条目，以链式加载GRUB Legacy引导加载程序。 更新模板文件/etc/grub.d/40_custom，而不是直接编辑配置文件。 清单15显示了执行此操作的典型条目。 这个来自我的Fedora 22安装。 它将根设置为（hd0,1），这在我的系统上是一个特殊的启动分区，我将在稍后讨论。
```shell
#!/bin/sh
exec tail -n +3 $0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.
menuentry "GRUB-Legacy /dev/sda1" {
    insmod chain
    insmod ext2
    set root=(hd0,1)
    chainloader +1
}
```
再次运行grub-mkconfig后，此条目将添加到配置文件的尾部，并显示在最后。

您将在本教程后面的“使用启动分区”部分中看到这些内容。

## LILO
多年来，LInux LOader（LILO）是最常见的Linux引导加载程序之一。您可以将LILO安装到可启动硬盘驱动器的MBR或分区的分区启动记录中。您也可以将其安装在可移动设备上，如软盘，CD或USB密钥。与GRUB和GRUB 2一样，如果您还不熟悉LILO，最好在软盘或U盘上练习。在Linux安装期间，通常指定引导管理器。如果选择GRUB，则可能未安装LILO。如果您尚未安装它，则需要为其安装软件包。您可能还需要安装lilo-doc软件包以获取其他文档和更多示例。从现在开始，我假设您已经安装了LILO软件包。如果需要帮助，请参阅有关包管理教程的系列路线图。您可以使用配置文件配置LILO，配置文件通常为/etc/lilo.conf。您可以使用liloconfig命令（通常位于/ usr / sbin中）生成启动配置文件，然后根据需要进行编辑。清单16中的配置文件是以这种方式生成的。该文件有相当好的注释，lilo和lilo.conf的手册页为您提供了更多帮助。这是一个典型的LILO配置文件，可以在Windows和一个或多个Linux系统的双启动系统上使用。和以前一样，我使用/来换行。
```shell
# LILO configuration file
# generated by 'liloconfig'
#
# Start LILO global section
lba32 # Allow booting past 1024th cylinder with a recent BIOS
boot = /dev/root
#compact # faster, but won't work on all systems.
# Boot BMP Image.
# Bitmap in BMP format: 640x480x8
bitmap = /boot/slack.bmp
# Menu colors (foreground, background, shadow, highlighted
# foreground, highlighted background, highlighted shadow):
bmp-colors = 255,0,255,0,255,0
# Location of the option table: location x, location y, number of
# columns, lines per column (max 15), "spill" (this is how many
# entries must be in the first column before the next begins to
# be used. We don't specify it here, as there's just one column.
bmp-table = 60,6,1,16
# Timer location x, timer location y, foreground color,
# background color, shadow color.
bmp-timer = 65,27,0,255
# Standard menu.
# Or, you can comment out the bitmap menu above and
# use a boot message with the standard menu:
#message = /boot/boot_message.txt
 
# Append any additional kernel parameters:
append=" vt.default_utf8=0"
prompt
timeout = 300
# VESA framebuffer console @ 640x480x64k
vga = 785
# Normal VGA console
#vga = normal
# Ask for video mode at boot (time out to normal in 30s)
#vga = ask
# VESA framebuffer console @ 1024x768x64k
# vga=791
# VESA framebuffer console @ 1024x768x32k
# vga=790
# VESA framebuffer console @ 1024x768x256
# vga=773
# VESA framebuffer console @ 800x600x64k
# vga=788
# VESA framebuffer console @ 800x600x32k
# vga=787
# VESA framebuffer console @ 800x600x256
# vga=771
# VESA framebuffer console @ 640x480x64k
# vga=785
# VESA framebuffer console @ 640x480x32k
# vga=784
# VESA framebuffer console @ 640x480x256
# vga=769
# ramdisk = 0 # paranoia setting
# End LILO global section
# Linux bootable partition config begins
image = /boot/vmlinuz
root = /dev/sda6
label = Slackware
read-only # Partitions should be mounted read-only for checking
# Linux bootable partition config ends
 
# Linux bootable partition config begins
image = /mnt/sda11/boot/vmlinuz-2.6.32-504.23.4.el6.x86_64 
    root="UUID=2f60a3b4-ef6c-4d4c-9ef4-50d7f75124a2"
append = "ro rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD \
    SYSFONT=latarcyrheb-sun16 crashkernel=128M  KEYBOARDTYPE=pc \
    KEYTABLE=us rd_NO_DM rhgb quiet"
    initrd = /mnt/sda11/boot/initramfs-2.6.32-504.23.4.el6.x86_64.img
    label = CentOS-vm
# Linux bootable partition config ends
 
# Windows bootable partition config begins
other = /dev/sda11
label = CentOS-6
 
# Windows bootable partition config ends
 
# Windows bootable partition config begins
other = /dev/sda1
label = GRUB-Legacy
 
# Windows bootable partition config ends
```
lilo命令使用您准备的配置文件设置LILO。 使用-b选项指定LILO引导扇区的位置。 例如，/ dev / sda表示第一个硬盘驱动器的MBR，/ dev / sda6表示第六个分区。

LILO支持您在GRUB和GRUB 2中看到的许多启动时功能。图7显示了清单16中配置文件的启动屏幕。
![此处输入图片的描述][7]

## 系统更新
大多数发行版都提供了更新系统的工具。 这些工具通常知道正在使用的引导加载程序，并且经常自动更新配置文件。 如果您构建自己的自定义内核，或者更喜欢使用具有非标准名称或位置的配置文件，那么您可能需要自己更新配置文件。

- 如果使用GRUB，则可以编辑/boot/grub/grub.conf文件以进行更改，GRUB stage 2加载程序在重新引导时读取文件。 您通常不需要仅因为添加新内核而重新安装GRUB。 但是，如果您移动分区或添加驱动器，则可能需要重新安装GRUB。 请记住，第1阶段加载器非常小，因此它具有第2阶段加载器的块地址列表。 移动分区并更改地址，以便第1阶段无法再找到第2阶段。我将介绍一些恢复策略，然后再讨论GRUB的1.5阶段加载器。
- 如果使用GRUB 2，则按照构建GRUB 2配置文件中的说明重建GRUB 2配置。
- 如果使用LILO，则必须在更新配置文件或更改（例如添加硬盘驱动器或删除分区）时运行lilo命令。
- 如果在不同分区中运行多个Linux系统，请考虑使用启动分区。

## 复原(Recovery)
现在，让我们看一下您精心准备的启动设置可能出错的一些事情，特别是在安装和启动多个操作系统时。 要记住的第一件事是抵制你最初的恐慌诱惑。 恢复通常只有几步之遥。 这里的策略可以帮助您解决各种类型的危机。任何有物理访问机器的人都有很多权力。 同样，任何有权访问GRUB命令行的人也可以访问系统上的文件，而无需运行系统提供的任何所有权或其他安全规定。 选择引导加载程序时，请牢记这些要点。 尽管GRUB 2正在成为主导，但LILO，GRUB或GRUB 2之间的选择在很大程度上取决于个人偏好。 选择最适合您特定需求和工作方式的引导器。

### 安装其他操作系统破坏了MBR分区
您安装另一个操作系统并无意中覆盖您的MBR。 某些系统（如DOS和Windows）始终安装自己的MBR。 通常很容易从这种情况中恢复过来。 如果您养成了每次运行lilo，重新安装GRUB或更新GRUB 2时创建恢复软盘，USB闪存驱动器或CD的习惯，那么您就可以免费使用。 从软盘启动到Linux系统并根据需要重新运行lilo，grub-install或grub2-install。

如果您碰巧没有自己的恢复媒体但仍然有几乎所有Linux发行版现场或安装媒体可用，您可以使用分发媒体的恢复模式或实时媒体来修复损坏的MBR或构建 正如您在本教程中所做的那样，恢复媒体。

### 你移除了分区
如果您移动了分区并忘记了引导设置，则会出现临时问题。 通常，LILO或GRUB拒绝加载。 LILO可能会打印一个'L'，表示第1阶段已加载然后停止。 GRUB会给你一个错误信息。 这里发生的是第1阶段加载器，它有一个要加载到第2阶段加载器的扇区列表，可以从它拥有的地址加载扇区，但扇区不再具有第2阶段签名。 至于被破坏的MBR的情况，你需要重新安装你的启动加载器，所以要么使用你所说的恢复光盘或Linux发行版。

您可能已经注意到配置示例为分区使用了一些通用唯一ID（UUID）（例如，清单1中所示的清单17中所示的代码段）。
```grub
title CentOS (2.6.32-504.23.4.el6.x86_64)
    root (hd0,10)
    kernel /boot/vmlinuz-2.6.32-504.23.4.el6.x86_64 ro \
           root=UUID=2f60a3b4-ef6c-4d4c-9ef4-50d7f75124a2 rd_NO_LUKS rd_NO_LVM \
           LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=128M \
           KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
    initrd /boot/initramfs-2.6.32-504.23.4.el6.x86_64.img
```
在UUID出现之前，MBR分区还可以使用e2label命令或分区工具（如gparted）分配标签。 这些还提供了与分区移动无关的级别。

我经常使用这样的UUID来帮助避免在移动分区时出现问题。 您仍然需要更新GRUB或LILO配置文件并重新运行lilo，但您也不必更新/ etc / fstab。 如果您在一个系统上创建分区映像并将其还原到另一个系统上的其他位置，则这尤其方便。 如果从可能并非总是连接在同一位置的驱动器（例如USB驱动器）启动，它也很方便。

您可以使用blkid命令显示磁盘的标签（如果有）和UUID，如清单18所示。如您所见，我的某些分区使用标签，而有些则不使用。
```bash
ian@attic-u14:~$ sudo blkid
/dev/sda1: LABEL="/grubfile" UUID="3c3de27e-779a-44d5-ad7a-61c5fd03d9e7" TYPE="ext3" 
/dev/sda2: UUID="158d605e-2591-4749-bf59-5e92e1b1c01d" TYPE="swap" 
/dev/sda3: UUID="ff0b87d2-6929-45df-88e1-d6d3e5cf3d6f" TYPE="ext4" 
/dev/sda5: LABEL="FEDORA22" UUID="7aefe7a0-97d5-45ec-a92e-00a6363fb1e4" TYPE="ext4" 
/dev/sda6: UUID="78a8c7de-cb86-45fe-ac04-be67ef52cb12" TYPE="ext4" 
/dev/sda7: LABEL="FEDORA 18" UUID="1b441a69-63e3-4771-a06b-5efecd1df07e" TYPE="ext4" 
/dev/sda8: LABEL="SUSE13-2" UUID="49d87897-791e-4e48-9efb-704eac447e43" SEC_TYPE="ext2" TYPE="ext3" 
/dev/sda9: UUID="10e82894-186f-4223-95c8-3468eb9b085d" SEC_TYPE="ext2" TYPE="ext3" 
/dev/sda10: LABEL="FEDORA20-64" UUID="8e6e2ebd-20b9-46e8-865f-893dd88c3206" TYPE="ext4" 
/dev/sda11: UUID="2f60a3b4-ef6c-4d4c-9ef4-50d7f75124a2" SEC_TYPE="ext2" TYPE="ext3" 
/dev/sda12: LABEL="UBUNTU-1404" UUID="943524cc-19a9-4237-ac9e-5c1a61a131e3" TYPE="ext4" 
/dev/sdb1: LABEL="GRUB-DATA" UUID="a36a3539-8393-4940-a893-472e9e1c868e" SEC_TYPE="ext2" TYPE="ext3" 
/dev/sdb2: LABEL="DATA-IAN" UUID="4c962b67-c646-467f-96fb-cbbd6de40140" TYPE="ext4" 
/dev/sdb3: LABEL="RESEARCH" UUID="0998d33c-3398-463d-b0e3-7c13ca0c675f" TYPE="ext3" 
/dev/sdb4: UUID="86ad1df3-fea4-47e5-bfdd-fb09f6c2e64a" TYPE="ext4" 
/dev/sdc1: LABEL="PICTURES" UUID="e3be4658-b79b-470d-82fe-bb434bcdcc2f" TYPE="ext4" 
/dev/sr0: LABEL="ISOIMAGE" TYPE="iso9660"
```
GRUB 2现在生成使用旧设备名称作为提示的配置文件，但实际上根据UUID（或标签）设置了根。 有关详细信息，请参阅GRUB 2手册。 我在前面为早期构建配置的Ubuntu 14系统的示例代码段如清单19所示。在最初将根设置为'hd0，msdos12'之后，下面的逻辑使用搜索命令和一些提示来定位实际的位置。 root设备（/ dev / sda12，如果没有任何改变）。
```shell
set root='hd0,msdos12'
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos12 --hint-efi=hd0,msdos12 \
    --hint-baremetal=ahci0,msdos12  943524cc-19a9-4237-ac9e-5c1a61a131e3
else
  search --no-floppy --fs-uuid --set=root 943524cc-19a9-4237-ac9e-5c1a61a131e3
fi
```
您之前从恢复闪存驱动器启动时看到了这种情况。 请记住，闪存驱动器变为（hd0），第一个硬盘驱动器变为（hd1）。

除了这里提到的方法和工具之外，Internet上还有几个恢复和引导软件包。 这些通常包括一定级别的可引导系统以及许多有用的恢复工具。 示例包括Knoppix和System Rescue CD等软件包（请参阅相关主题的链接，或在Internet上搜索此类软件包的许多优秀评论之一。

### 使用boot分区
另一种恢复或可能避免恢复的方法是使用单独的分区进行引导。正如您刚才所看到的，GRUB 2对系统变化的适应能力更强。但是对于GRUB Legacy和LILO，如果您的测试系统上有多个可能经常重建的发行版，则启动分区可能特别有用。启动分区不需要非常大，大约100MB左右。将此分区放在不太可能移动的位置，以及通过添加或删除另一个分区不太可能移动其分区号的位置。在混合的Windows和Linux环境中，/ dev / sda2（或/ dev / hda2取决于磁盘的标记方式）通常是启动分区的不错选择。实际上，您之前看到的清单1显示了我在系统上使用的小型启动分区（/ dev / sda1）中的条目。

虽然我为本教程的目的添加了一个条目来直接启动到CentOS，但我通常的策略是保持条目简单并使用它们链式加载另一个引导加载程序，或加载GRUB 2 core.img文件。您在Grub Legacy中引导GRUB 2部分中看到的示例（反之亦然）使用了这个简单的策略。如果您确实使用直接引导到特定内核的条目，则需要在更新目标系统时手动更新它们。尽可能避免额外的工作。图8显示了我简单的GRUB菜单。
![此处输入图片的描述][8]
对于这个分区，我使用了我在科罗拉多州大沙丘国家公园拍摄的照片制作的自定义闪光图像。 有关制作自己的初始图像的更多信息，请参阅手册页或在线搜索。 图9显示了使用/etc/grub.d/40_custom文件添加到Fedora 22 GRUB 2菜单末尾的条目。
![此处输入图片的描述][9]
当您的根分区使用引导加载程序不支持的文件系统时，会出现启动分区的另一个原因。例如，当根分区（/）使用LVM时，通常会将/ boot分区格式化为ext2或ext3，而GRUB Legacy不支持。

如果系统上有多个发行版，请不要在它们之间共享/ boot分区。请记住设置LILO或GRUB以从稍后将作为/ boot挂载的分区引导。还要记住，分发的更新程序通常会更新该系统的GRUB或LILO配置。在具有多个系统的环境中，您可能希望将其自身/ boot分区作为主系统保留，并在其中一个系统的更新需要时手动更新该配置文件。另一种方法是让每个系统将引导加载程序安装到自己的分区引导记录中，让主系统简单地为各个系统链接加载分区引导记录，为您提供一个两阶段菜单过程，就像我使用的那样。

## 针对UEFI和GPT的考量
虽然本教程侧重于MBR格式的驱动器，但许多概念仍适用于GPT格式的驱动器。 UEFI固件与BIOS完全不同，功能更强大。当然，这带来了新的挑战。其中一项新功能是安全启动的概念，它只允许签名的二进制文件启动。许多UEFI系统仍然支持传统模式启动，这允许旧系统在硬件上启动。 Windows 8需要UEFI和安全启动以及GPT格式的磁盘，因此如果要与Windows 8或更高版本一起安装，则需要了解有关UEFI和安全启动的信息。

一些现有的Linux发行版，例如Ubuntu和Fedora，以及它们的衍生产品支持在启用安全启动的UEFI系统上启动。建立信任链的方法在Linux内核开发社区中引起了一些争议。我将向您展示如何将Ubuntu 15.04分发ISO映像解压缩到USB闪存驱动器上，以便您可以探索设置。

在本练习中，我使用Ubuntu 14系统将小型USB闪存驱动器格式化为GPT，然后创建一个2GB分区，如清单20所示。我将分区格式化为FAT32，因为UEFI固件需要FAT32分区中的某些文件。小心使用合适的设备;你的可能不会是/ dev / sdf。
```shell
ian@attic-u14:~$ sudo parted /dev/sdf
GNU Parted 2.3
Using /dev/sdf
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) mklabel gpt
Warning: The existing disk label on /dev/sdf will be destroyed and all data on
this disk will be lost. Do you want to continue?
Yes/No? yes                                                               
(parted) mkpart primary fat32 1MB 2048MB                                  
(parted) toggle 1 boot                                                  
(parted) print                                                            
Model:  USB DISK 2.0 (scsi)
Disk /dev/sdf: 15.5GB
Sector size (logical/physical): 512B/512B
Partition Table  : gpt
 
Number  Start   End     Size    File system  Name     Flags
 1      1049kB  2048MB  2047MB  fat32        primary  boot
 
(parted) quit                                                             
Information: You may need to update /etc/fstab.                           
 
ian@attic-u14:~$ sudo mkfs.fat -F 32 /dev/sdf1
mkfs.fat 3.0.26 (2014-03-07)
```
准备好闪存驱动器后，您需要安装它。 然后，您需要将Ubuntu 15 ISO映像解压缩到它。 清单21显示了可以执行此操作的许多可能方法之一。
```shell
ian@attic-u14:~$ sudo mkdir /mnt/u15iso /mnt/flashdrive
ian@attic-u14:~$ sudo mount ~/Downloads/ubuntu-15.04-desktop-amd64.iso /mnt/u15iso/ -o ro,loop=/dev/loop1
ian@attic-u14:~$ sudo mount /dev/sdf1 /mnt/flashdrive/
ian@attic-u14:~$ sudo rsync -a -H /mnt/u15iso/ /mnt/flashdrive
rsync: symlink "/mnt/flashdrive/ubuntu" -> "." failed: Operation not permitted (1)
rsync: symlink "/mnt/flashdrive/dists/stable" -> "vivid" failed: Operation not permitted (1)
rsync: symlink "/mnt/flashdrive/dists/unstable" -> "vivid" failed: Operation not permitted (1)
rsync error: some files/attrs were not transferred (see previous errors) (code 23) at \
main.c(1183) [sender=3.1.0]
ian@attic-u14:~$ diff -rq /mnt/u15iso/ /mnt/flashdrive
Only in /mnt/u15iso/dists: stable
Only in /mnt/u15iso/dists: unstable
Only in /mnt/u15iso/: ubuntu
i
```
在卸载闪存驱动器之前，请查看其中的一些文件。 如果列出根目录，则会看到两个目录，EFI和boot，以及其他文件和目录。 引导目录是GRUB 2引导目录，而EFI目录是UEFI固件搜索要引导的已签名二进制文件的目录。 这是必须具有FAT文件系统（或CD上的ISO 9660文件系统）的目录。 这就是我将分区格式化为FAT32的原因。 清单22说明了这些文件。 您现在可以卸载并弹出闪存驱动器，并尝试在启用了安全启动和禁用旧启动的系统上启动它。
```shell
ian@attic-u14:~$ ls /mnt/flashdrive/
autorun.inf  casper  EFI      isolinux    pics  preseed             wubi.exe
boot         dists   install  md5sum.txt  pool  README.diskdefines
ian@attic-u14:~$ ls /mnt/flashdrive/EFI
BOOT
ian@attic-u14:~$ ls /mnt/flashdrive/EFI/BOOT/
BOOTx64.EFI  grubx64.efi
ian@attic-u14:~$ umount /mnt/flashdrive 
umount: /mnt/flashdrive is not in the fstab (and you are not root)
ian@attic-u14:~$ sudo umount /mnt/flashdrive 
ian@attic-u14:~$ sudo eject /dev/sdf
i
```


  [1]: https://www.ibm.com/developerworks/library/l-lpic1-102-2/boot-grub-cd.jpg
  [2]: https://www.ibm.com/developerworks/library/l-lpic1-102-2/centos-grub-cd-img.jpg
  [3]: https://www.ibm.com/developerworks/library/l-lpic1-102-2/edit-grub-1.jpg
  [4]: https://www.ibm.com/developerworks/library/l-lpic1-102-2/edit-grub-2.jpg
  [5]: https://www.ibm.com/developerworks/library/l-lpic1-102-2/grub2-rescue-boot.jpg
  [6]: https://www.ibm.com/developerworks/library/l-lpic1-102-2/ubuntu-grub2.jpg
  [7]: https://www.ibm.com/developerworks/library/l-lpic1-102-2/lilo-boot.jpg
  [8]: https://www.ibm.com/developerworks/library/l-lpic1-102-2/boot-part-grub.jpg
  [9]: https://www.ibm.com/developerworks/library/l-lpic1-102-2/grub2-chain-load.jpg
